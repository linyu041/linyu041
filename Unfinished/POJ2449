#include<queue>
#include<vector>
#include<algorithm>
#include<limits.h>
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define U(i,j,k) for(int i=j;i<=k;++i)
#define D(i,j,k) for(int i=j;i>=k;--i)
const int N=1005,M=100005;
typedef pair<int,int> pii;
int n,m,s,t,k,dist[N],tims[N];
struct Edge
{
	int tot,la[N],nxt[M],v[M],w[M];
	void clear()
	{
		memset(la,0,sizeof(la));
		tot=0;
	};
	void AddE(int x,int y,int z)
	{
		v[++tot]=x;nxt[tot]=la[x];la[x]=tot;w[tot]=z;
	};
}e,g;
struct Data
{
	int now,w;
};
struct cmp
{
	bool operator () (Data &tmp1,Data &tmp2)	const 
	{
		return tmp1.w> tmp2.w;
	};		
};
priority_queue<Data,vector<Data>,cmp>q1;
void DJ(int x)
{
	for(register int i=1;i<=n;++i)	dist[i]=INT_MAX;
	dist[x]=0;
	Data tt,r;
	tt.w=0;tt.now=x;
	q1.push(tt);
	while(!q1.empty()) 
	{
		tt=q1.top();
		q1.pop();
		if(tt.w>dist[tt.now])	continue;
		for(int i=g.la[tt.now];i;i=g.nxt[i])
		{
			if(dist[g.v[i]]>dist[tt.now]+g.w[i])
			{
				dist[g.v[i]]=dist[tt.now]+g.w[i];
				r.now=g.v[i];r.w=dist[g.v[i]];
				q1.push(r);
			}
		}
	}
}
struct Data1
{
	int f,g,now;
};
struct cmp1
{
	bool operator () (Data1 &tmp1,Data1 &tmp2) const
	{
		return tmp1.f>tmp2.f;
	};
};
Data1 make(int f,int g,int now)
{
	Data1 h;h.f=f;h.g=g;h.now=now;
	return h;
};
priority_queue<Data1,vector<Data1>,cmp1> q;
void A()
{
	q.push(make(dist[s],0,s));
	while(!q.empty())
	{
		Data1 tt=q.top();
		q.pop();
		++tims[tt.now];
		if(tt.now==t&&tims[tt.now]==k)	
		{
			printf("%d\n",tt.g);
			exit(0);
		}
		for(int i=e.la[tt.now];i;i=e.nxt[i])
		{
			q.push(make(tt.g+e.w[i]+dist[e.v[i]],tt.g+e.w[i],e.v[i]));
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int u,v,w;
	U(i,1,m)
	{
		scanf("%d%d%d",&u,&v,&w);
		e.AddE(u,v,w);
		g.AddE(v,u,w); 
	}
	scanf("%d%d%d",&s,&t,&k);
	DJ(t);
	if(dist[s]==INT_MAX)
	{
		printf("-1");
		return 0;
	}
	A();
	return 0;
}
